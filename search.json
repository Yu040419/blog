[{"title":"CSS Animation","date":"2024-02-13T12:48:18.000Z","url":"/blog/article/CSS-Animation/","tags":[["CSS","/blog/tags/CSS/"]],"categories":[[" ",""]],"content":"User StoryThe user sees the roulette game, and only after clicking the start button, the API call is made to retrieve prize information. Once the prize data is obtained and the roulette is spun to the designated position, the winning information will be displayed. KeyframesCSS animations are created using keyframes. Keyframes define the styles at various points in the animation timeline, allowing for smooth transitions between them. from &#x2F; to &#x3D; 0% &#x2F; 100% Automatic calculation if no start or end is specified Use percentage with numbers Animation PropertiesTo apply keyframes to an element, you’ll use the animation property. This property specifies the animation name, duration, timing function, iteration count and fill mode. Animation NameThe name of the keyframe animation you want to apply. case sensitive with or without quote reserved word initial, None is illegal for naming, but could be &#39;None&#39; Animation Duration The total time taken for the animation to complete one cycle (specified in seconds or milliseconds). default set to 0 Animation Timing Function Specifies the speed curve of the animation. Common values include ease, linear, ease-in, ease-out, and ease-in-out. default set to ease cubic-bezier() Animation Delay The time to wait before starting the animation (specified in seconds or milliseconds). default set to 0 Animation Iteration CountSpecifies the number of times the animation should run. Use a finite number or infinite for continuous animation. default set to 1 Animation Fill ModeDescribes how an element’s style is applied before and after the animation. Common values includenone, forwards, backwards, both. default set to none Putting it all together: This example combines various parameters to create an animation named rotate with a duration of 5 second, easing out, a delay of 500 milliseconds, running infinite times, and pausing the animation in the end. Animation Event animationstart animationend animationiteration animationcancel Difficulties rotate to certain position smooth animation rate position More Info Animate.style Animation examples Conclusion strong interesting start and try References Animation-W3C Animation-MDN "},{"title":"Securing Your Web Content with Content Security Policy (CSP)","date":"2024-02-13T09:59:12.000Z","url":"/blog/article/Securing-Your-Web-Content-with-Content-Security-Policy-CSP/","tags":[["資訊安全","/blog/tags/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/"],["CSP","/blog/tags/CSP/"]],"categories":[[" ",""]],"content":"What is CSPContent Security Policy, or CSP, is a security standard implemented by web browsers to mitigate the risks of Cross-Site Scripting (XSS) attacks. It serves as an added layer of protection by defining and enforcing a set of rules that dictate which resources a browser is allowed to load for a specific web page. These resources include scripts, stylesheets, images, fonts, and more. Sometimes you may see mentions of the X-Content-Security-Policy header, but that’s an older version and you don’t need to specify it anymore. How To Implement CSP HTTP Response Header HTML meta Directives Default-src：Specifies the default sources for content if no other directive applies. Script-src：Defines valid sources for JavaScript, allowing you to whitelist specific domains or sources. Inline scripts are blocked by default. The execution of all JS event handlers from inline HTML markup are blocked by default. Style-src：Similar to script-src but for stylesheets. Inline styles are blocked by default. Img-src：Specifies the allowed sources for images. Font-src：Determines the sources for web fonts. Connect-src：Specifies the valid sources for network requests. Applies to XMLHttpRequest (AJAX), WebSocket, fetch(), &lt;a ping&gt; or EventSource. If not allowed the browser emulates a 400 HTTP status code. Form-action：Restricts the URLs where forms can be submitted. Frame-ancestors：Controls which websites can embed your content in frames. Source Source Description Example * Used as a wildcard. It allows any URL except the data:, blob: and the filesystem: schemes. script-src * ; ‘none’ Prevents loading resources from any source. media-src ‘none’ ; ‘self’ Allows loading resources from the same origin (host, and port). default-src ‘self’ ; data: Allows loading resources via the data scheme (e.g. Base64 encoded images). img-src data: ; specificDomain.com Allows loading resources from the specific domain media-src specificDomain.com ; *.example.com Allows loading resources from any subdomain under example.com. script-src *.example.com https: Allows loading resources only over HTTPS on any domain. object-src https: ; ‘unsafe-inline’ Allows use of inline source elements such as style attribute, onclick, or script tag bodies (depends on the context of the source it is applied to) and javascript: URIs script-src ‘unsafe-inline’ ; ‘unsafe-eval’ Allows unsafe dynamic code evaluation such as JavaScript eval() script-src ‘unsafe-eval’ ; ‘nonce-‘ An allowlist for specific inline scripts using a cryptographic nonce (number used once). &lt;script nonce=&quot;2726c7f26c&quot;&gt; doSomethingBad() &lt;/script&gt; script-src ‘nonce-2726c7f26c’; ‘-‘ A sha256, sha384 or sha512 hash of scripts or styles. This value consists of the algorithm used to create the hash followed by a hyphen and the base64-encoded hash of the script or style. &lt;script&gt;doSomething();&lt;/script&gt; script-src ‘sha256-RFWPLDbv2BY+rC’; PracticeValid Image resource ANSWER Tips Open your devtool, and check Response Headers of Network tab Facebook HackMD MDN Syntax Error No colon between directive and source : Separate policy With semicolon ; Separate source with space Specific source with single quote &#39;self&#39; Testing Tools by Google Report Only Mode: During implementation, use the Content-Security-Policy-Report-Only header to receive reports about policy violations without enforcing the policy. Content-Security-Policy-Report-Only: report-to /csp-report/ Blocked Content: If you notice certain resources are not loading, check the browser console for CSP error messages. Adjust your policy accordingly. Browser Compatibility References Content-Security-Policy - HTTP | MDN Content-Security-Policy (v2014) | DEVCORE Content Security Policy Cheat Sheet | OWASP Content Security Policy (CSP) Quick Reference Guide Conclusion Powerful Careful Keep changing "},{"title":"URQL 的基本介紹與常見應用","date":"2022-06-23T15:47:49.000Z","url":"/blog/article/urql/","tags":[["GraphQL","/blog/tags/GraphQL/"]],"categories":[[" ",""]],"content":"URQL，全名為 Universal React Query Library。從名稱就可以看得出來，最初是基於 React 而生的 Library。 為什麼我說是「最初」呢？就是因為其強大的團隊，也開發出了支援 Vue (3) 及 Svelte 等其他前端框架。在整合度非常高的狀況下，卻又以輕便、高度客製化、多功能、簡單好上手等多樣特色聞名。 整合性高：除了支援前端的 React, Vue, Svelte 框架外，URQL 本身還提供 devtool 可供使用者開發 debug 使用。 輕便：bundle size 僅 7.1 kb，相較其他 GraphQL Client Library，Apollo Client 最迷你的版本也需要 32 kb，React Relay 也要 34 kb。 多功能：URQL 本身提供非常多樣化的功能，官方有提供一張 比較 URQL 與其他 GraphQL Client 的表格，就可以看到支援相當多的功能，包含 Stale while Revalidate &#x2F; Focus Refetching &#x2F; Dependent Query 等等。 接下來就來看看，該如何實際應用 URQL 吧！ Install Setting Request PolicyURQL 的請求政策共分成四種，分別是： cache-first：預設值，有快取的時候從快取拿值，沒有快取的時候，就發送請求取得資料。 cache-and-network：會先回傳快取資料，並同時在背後發送請求。一般推薦以這個方式，可以達到使用者體驗與取得正確資料的平衡。 當有快取資料，發送請求時，isFetching 值會是 false。所以使用者會優先看到快取資料，不會顯示 loading 內容。 network-only：忽略快取，每次都會發送請求。 cache-only：只回傳快取資料，若是沒有快取資料，會回傳 null。 useQuery GET query 內容或是變數有變動時，會自動發出 request。 範例： data ref 值，最重要的資料 存取時可透過 .value 存取 data 值。要記得再 . 存取 query 內容的值，詳細可看上方範例。 fetching ref 值，Boolean，true 表示正在抓取資料 轉變過程：undefined -&gt; true -&gt; false error ref 值，沒有錯誤的時候拿到的值會是 undefined 文件 中把錯誤稱為 combinedError，因為 error 包含兩種狀況，分別是 networkError 以及 graphQLErrors。 可以透過 error.value.message 拿到錯誤訊息，這個錯誤訊息會合併兩種錯誤情況， error.value.name 會拿到錯誤名稱，名稱會是 &#39;networkError&#39; 或 &#39;graphQLErrors&#39;。 error 可以跟 data 共存，也就是說有可能出現，同時有 data 也有 error 的狀況，因為 GraphQL query 可以是部分失敗的。error 這時候就會拿到 graphQLErrors。 networkError任何跟網路連線相關的錯誤，就會被歸類到 networkError。存取時是透過 error.value.networkError 存取。 networkError 中又包含兩個 property，分別是 message 及 networkError。 graphQLErrors跟 GraphQL 相關的錯誤就會被歸類到這裡，舉凡 scalar type 不對、缺少某些 field 或是 variables，GraphQL 格式不對等等。 graphQLErrors 中也包含兩個 property，分別是 message 及 graphQLErrors。 跟 networkError 不一樣的是，graphQLErrors value 的 type 是一個陣列，因為可能併發多種 GraphQL 的錯誤。 isPaused ref 值，Boolean，true 代表目前 query 有被暫停 pause function，如果 query 可執行，可用來暫停執行 query。 pause 是用來提供在 setup 外、也就是 template，也可以暫停執行 query。 resume function，如果 query 被暫停執行，可用來啟動執行 query。 resume 是用來提供在 setup 外、也就是 template，也可以啟動執行 query ( 但不是立即執行，只是可以執行 )。 executeQuery function，立即執行 query， 執行此 function 的情況，通常都是用來希望可以重新取得最新資料，所以一般都會在參數內放入 requestPolicy: &#39;network-only&#39;，詳細可參考上方範例。 useMutation CREATE &#x2F; UPDATE &#x2F; DELETE 範例： useMutation 跟 useQuery 大同小異，比較特別的是，有兩種方式可以取得 response： 透過 useMutation 回傳的 data 執行 function 後，透過 .then((&#123; data &#125;) =&gt; &#123;&#125;) 或是 async / await 取得 一般來說會比較推薦透過第二種方式取值。 useSubscription 基於 websocket 所實作 在使用 useSubscription 之前，需要先做好設定，並下載相關 package。 Setting Usage ConclusionURQL 簡單介紹就到這邊告一個段落，這邊介紹到的都是一些常用到、基礎的功能，這邊大概可以涵括到實際應用場景的七八成。沒有提到的部分，包含像是 URQL 的快取機制，有分成 Document Cache 及 Normalized Caching，之後有機會再介紹給大家～ Reference URQL 官網 "},{"title":"GraphQL 系列文（三）：Mutation & Subscription","date":"2022-06-22T12:28:01.000Z","url":"/blog/article/GraphQL-mutation-and-subscription/","tags":[["GraphQL","/blog/tags/GraphQL/"]],"categories":[[" ",""]],"content":"假設今天有個 GraphQL Schema 如下，今天需要發送一個請求，請求內容中需要拿到使用者的 ID、名稱、年紀、身高 (公分)、所有貼文的標題及內容等。 那該如何寫請求呢？答案我放在這篇文章最下方，可以先自己練習看看。 如果看不懂 Schema、或是不知道如何寫 Query，的，可以先參考系列文章的前兩篇，GraphQL 系列文（一）：透過 The Schema Definition Language (SDL) 撰寫 GraphQL Schema 及 GraphQL 系列文（二）：透過 Query 存取資料，複習一下再繼續往下看。 Mutation 跟執行 Query 一樣，在執行 mutation 時，一定會加上 keyword mutation 這個 operation type，後面再加上這個 mutation 的名稱，官方說法為 operation name。至於 operation name 的好處，在這邊就不再說一次，可以參考上一篇文章。 從以上的 mutation 可以發現： 有使用 Input Object Type 取代 Arguments 透過 $input 這個變數去管理 mutation 的 Input 將 createPost 取了暱稱 post1 除了新增貼文外，createPost 這個 mutation 還存取了 CreatePostPayload 內容中的，createPost。 CreatePostPayload 跟 Query 的概念相同，都可以自由進行存取 上方的 Mutation 當中，拿到的資料顯示狀況會呈現如下： Input Object Type在討論 Schema 的時候有提到，Mutation 有兩個以上的 Argument 參數時，就會建議透過 input Type 來作為 Object Type 的 Argument。 以上方這個 input 為例，這個 input 需要 title 及 content 這兩個 Field Names，兩個的 Field Types 都是 String。而且兩個都有 ! 這個 Type Modifier，顯示這個兩個 field 都是必填。 Mutation 設計建議1. 動詞開頭比方說 createPost &#x2F; updatePost 等。 2. 建議每個 mutation 搭配自己的 input 及 payload，方便未來的擴展比方說 mutation 名稱為 updatePost 時，input 為 UpdatePostInput、payload 為 UpdatePostPayload。 3. 依照商業邏輯細分 Mutation剛開始大家會將 RESTful 的 CUD 來對應 Mutation，但 Mutation 可以完全因應前端需求調整，因此如果需要細分的就細分，需要一次更改多個欄位的就包在一隻 Mutation 中。 4. 參數盡量使用 input object type 管理參數除了易讀性較高外，input object type 經常也能被重複使用。 5. 設計每個 mutation 的專屬回傳資料概念上跟之前 RESTful 都會有個 response 內容有點類似，建議為每個 mutation 加上個別獨立的 Object Type。 練習在上面的 Schema 當中，只有 CreatePost 及 DeletePost 的功能，所以可以試著建立看看 UpdatePost 來編輯貼文。並試著發送 mutation 的 request，然後獲取該文章更新後的內容及錯誤訊息，答案一樣會放在下方。 Subscription在前面提到的 Query 跟 Mutation，基本上都是常見的由 Client 端發送 request 給 Server，當 Server 接收到請求後，再回傳 Response 給 Client。 一般來說若希望可以由 Server 主動推送資料給 Client 端的話，會透過 WebSocket 來實作。在 GraphQL 當中，Subscription 就是扮演這樣的角色，開發者不需自行串接，只需要透過與 Query 相似的語法，就可以輕鬆實現（GraphQL Subscription 底層也是透過 WebSocket 實作）。 Subscription Library TL;DR: 下載 graphql-ws 作為 Subscription Libray 在實作 Subscription 之前，需要先選擇前後端介接的 Protocol，專案的前後端都必須使用同一個 Protocol，才可以成功實作 Subscription。 而在 GraphQL 當中有兩個熱門的 Library 可供選擇，分別是 subscriptions-transport-ws 及 graphql-ws。 神奇的地方來了！Library 名稱是 subscriptions-transport-ws 的 Sec-WebSocket-Protocol 名稱是 graphql-ws。而 Library 名稱是 graphql-ws 的 Sec-WebSocket-Protocol 名稱是 subscriptions-transport-ws。 是的，你沒看錯，他們的 Library 名稱跟 Protocol 名稱剛好顛倒，非常容易造成混淆 QQ 而 Library 名稱是 subscriptions-transport-ws 目前已經不再維護了。不管是 Apollo 官方及 subscriptions-transport-ws Libray 本身，都推薦使用 graphql-ws 這個 Libray。所以毫無懸念，就下載 graphql-ws 吧！ graphql-ws 相關的設定，可以參考 Apollo 官方文件。 Client-Side 以上方為例，可以看到架構上基本上都跟 Query 及 Mutation 無異，都是由 operation Type + Operation Name。如果需要 Argument 則都透過變數代為管理。 結語GraphQL 系列文章就差不多這樣告一個段落，一開始介紹了最重要的 Schema，可以理解為前後端都需要遵守的 Spec。Schema 訂好之後，GraphQL 會協助把關，如果前端傳送非 Schema 訂定的資料類別或架構，就不會發送 Request 給後端；反之亦然，後端若回覆非 Schema 訂定的資料類別或架構，就無法成功發送 Response 給前端。 接下來了解了 Schema 三本柱，Query、Mutation 及 Subscription。Query 跟 Mutation 都是基於 HTTP 傳輸協定。Query 用來取得資料，而 Mutation 用來新增、修改、刪除資料。Subscription 則是基於 WebSocket 傳輸協定，讓 Server 可以主動推送訊息給 Client，常用於顯示一些即時資料。 上方的所有程式碼，都有建立 codesandbox 作為 Live Code Demo，想玩玩的都可以點 Codesandbox 連結去玩玩看～ Answer取得使用者相關資料 編輯貼文Schema Mutation Reference Think in GraphQL 系列 Apollo Docs "},{"title":"GraphQL 系列文（二）：透過 Query 存取資料","date":"2022-03-09T13:05:02.000Z","url":"/blog/article/GraphQL-query/","tags":[["GraphQL","/blog/tags/GraphQL/"]],"categories":[[" ",""]],"content":"在上一篇文章 GraphQL 系列文（一）：透過 The Schema Definition Language (SDL) 撰寫 GraphQL Schema 中有提到，GraphQL 有三種存取資料的方式 (operation type)，主要常被使用的是 Query 查詢資料，以及 Mutation 新增、編輯、刪除資料。 因為底下會直接使用 GraphQL 的相關名詞，不會對名詞進行解釋，因此建議先閱讀過上一篇文章，對 GraphQL 有基礎理解後，再繼續往下看。 Query 在執行 query 時，一定會加上 keyword query 這個 operation type，後面再加上這個 query 的名稱，官方說法為 operation name，operation name 不是必要，但對開發及後續維護上非常方便，建議一定要加上，好處如下： 增加易讀性 DEBUG 時有 operation name 就不會找不到 query 搜尋 request 時快速有效率，很方便 Query 有幾個特色如下： 可巢狀存取 可自由選擇存取哪些資料 可一次存取多個 field 或多個 object type 存取到 object type 時，需展開繼續存取內部的 field（ 才知道說到底要什麼資料 ） argument 參數若是 schema 中要求帶上參數，則必須在 query 名稱後面以括號帶上參數。 一般參數會透過變數處理。 變數會以 $ 進行宣告。 每個 field 及 object type 都可以放上參數。 聲明與 schema 相符的 scalar type 及透過 ! 表明是否為必要帶上的參數。 可以透過 = 給定參數預設值。 alias 別名今天若要一次取兩個相同名稱的 field 時，GraphQL 會報錯，因為一筆 Query 中，不可以有相同的 field。這時候就可以透過 alias 別名的方式，來重新對這個 object type 進行命名。 以上的結果，得到的 response 就會是： 在剛上面的範例中，取的資料都相同，都是 user 資料中的 name 跟 email。在 GraphQL 有沒有其他方式方式，可以像 function 一樣，將相同的地方抽出來，重複使用呢？ 還真的有！那就是 fragment！ fragment 片段透過 fragment 這個關鍵字宣告。使用時，再以類似展開元素，透過 ... 使用即可。在 fragment 中，一樣可以透過變數取值。而上面一樣的 code 透過 fragment 重寫後，變成以下： inline fragment當今天若是想要 query 的資料型別，不是 object type &#x2F; field，而是 Interface 跟 Union type 時，這時候就會需要透過 inline fragment 進行存取。 拿上一篇提到的範例來說： 在 query 的時候，就會以 inline fragment 呈現： directive 指令在上一篇文章中有提到官方原生有三個 directive 指令，schema 中會使用一個。而在 query 中會使用到剩餘的兩個。 在了解之前，可以先猜猜看，以下的 query，最後會拿到什麼資料： @include 如果 boolean 是 true 的話，就存取這個欄位，一般會透過變數管理 boolean。 @skip 如果 boolean 是 true 的話，就略過這個欄位，也就是不存取，一般會透過變數管理 boolean。 所以猜對了嗎？在上面的 query 中，最後拿到的資料是： 噹啷！就是只有 name！ 結語Query 的部分大概就到這邊，Mutation 可參考下一篇。 Reference 官網 Think in GraphQL 系列文 "},{"title":"GraphQL 系列文（一）：透過 The Schema Definition Language (SDL) 撰寫 GraphQL Schema","date":"2022-01-13T13:48:44.000Z","url":"/blog/article/SDL/","tags":[["GraphQL","/blog/tags/GraphQL/"]],"categories":[[" ",""]],"content":"SDL 是建立 GraphQL Schema 的語言，而 Schema 則是定義 GraphQL API 的重要骨幹，包含資料架構格式和型別。 在了解 Schema 之前，先來了解 GraphQL 是什麼。 GraphQL GraphQL 是一個用來查詢 API 的語言 (Query Language)，也是一個基於型別系統來執行及查詢的 server-side runtime。 GraphQL 是設計用來快速開發高彈性、對開發者友善的 API。在開發完 API 後，會自動建立出一個線上的 IDE，在這個 IDE 中，可以測試發送 request，並得到相關的 response。在這個 IDE 中，也可以看得到完整的 API 文件。這邊有 Github 提供的 範例 IDE，有興趣的可以玩玩看～ 在上方的 IDE 中，可以看到版面被切分成三個區塊。左邊是供 client 端撰寫的 query。Query 區塊下方可以寫入 query 要帶上的變數，並設定 request header。若要執行 query，可以按上方的播放鍵執行，執行後得到的結果就會出現在中間的區塊。而最右邊的就是自動建立出來的 API 文件。 當 GraphQL 的服務架起來時，便可以接受 GraphQL query，開始進行驗證及執行相關操作。GraphQL 會先確認 query 的型別與內容是否符合 Schema，驗證成功後才會執行 API 的資料存取。除此之外，GraphQL 還可以串接 RESTful API，詳細可以參考 官方教學 - Wrapping a REST API in GraphQL。 GraphQL 不依賴於任何特定的資料庫或是 storage engine，而是建立在開發者所撰寫出來的 code 及數據。透過 GraphQL 開發 API 時，首先要了解的就是他的 type System，以及該如何自定義型別 (define type)，並依據每個 type 實作相對應的 resolver（可以理解成實作 API 的地方）。 所以接下來，就來看看建立 GraphQL 的 Type System 的 SDL。 存取方式在 GraphQL 中，資料存取方式分成三種，分別是 query, mutation 跟 subscription。 query：查詢資料 mutation：新增、編輯、刪除資料 subscription：擺脫以往發送 request 後得到 response 的方式，而是以透過 websocket 的方式，client 端訂閱某個資料後，Server 端一有新的資料後就會主動發送給 client。 資料型別 Scalar Types 可以讓 Client 與 Server 的開發者對於資料格式有共同的認知 強迫 Client 送出正確格式的 query 強迫 Server 回覆正確格式的 response 預設 Scalar Types資料型別預設分成五種，分別是： Int：32-bit 整數 Float：double precision 雙精度的浮點數 String Boolean ID：ID 一般來說會以 string 方式呈現，但當前端輸入 id 為 “483109245” (string) 或是 483109245 (int) 都會被 GraphQL 所接受。 自訂 Scalar Types除了以上的型別外，也可以自訂型別，常見的有 Date, URL, Email, JSON 等等。可以動手 實作，也可以透過 套件。 Syntax 語法在了解以上基礎後，接下來就可以直接來看看，如何透過 SDL 訂定 GraphQL 的 Schema。 CommentSDL 的註解方式分成三種，分別是 #、&quot; 及 &quot;&quot;&quot;。 #：SDL 單行註解方式，不會呈現在自動生成的 GraphQL 文件中。 &quot;：SDL 單行註解方式，會呈現在自動生成的 GraphQL 文件中，經常用來備註 field definition 。 &quot;&quot;&quot;：SDL 多行註解方式，會呈現在自動生成的 GraphQL 文件中。 non-nullable !! 在 SDL 當中，代表一個不能為 null 的值。GraphQL 會保證傳來的資料，不會是 null。 String!：這個值不可為 null，而且 scalar type 是字串 [User!]：這個值可能為 null，但陣列中不可為 null，且陣列中的 object type 為 User [User]!：這個值不可能為 null，但陣列中可為 null，且陣列中的 object type 為 User [User!]!：這個值不可為 null，且陣列中也不可為 null，陣列中的 object type 為 User 值得注意的是，假設今天設定資料為 myField: [String!]，那可以猜猜看，以下哪個是合法的資料，哪個是不合法的： 為了不爆雷，答案在最下方，可以先想一下有答案後，再往下滑。 directive 指令 directive 指令以 @ 宣告 是一種語法糖 可以 custom directive 原生有三個指令，一個用在 schema 就是 @deprecated(reason: String!)，另外兩個指令可參照 如何透過 GraphQL 存取資料 － Query。 @deprecated(reason: String!)：schema 使用，是用來呈現在文件上，告訴 client 端盡量不要存取該欄位的用法，因此一定需要帶上 reason 的值。 Schema在還不太清楚前，可以先簡略的將 GraphQL Schema 想像成 DB Schema。一個 DB 可以有多個 Table，而一個 Schema 可以有多個 type；DB 中的 table 中有多個欄位，可分別設置資料型別，而 GraphQL type 也可以有多個 field (欄位)，每個欄位的資料也可設定型別。 GraphQL 中的語法關鍵字 Schema 被官方稱為 Root Types，可以理解成所有存取資料的 entry point 進入點。在上面我們有提到存取方式有三種，因此 Schema 最多也只會包含三種類型： Type &#x2F; Field type 是宣告 Object Type 的關鍵字。Object Type 中若有可選的欄位，則是 Field。 底下範例中： Query 是 Object Type 的名字，供查詢。 設定可以查詢的 Field 欄位被稱為 Field Names，這邊有有四個，分別是 hello, me, users, user。 string User User! [User!]! 被稱作 Field Types。 users 這個 Field Name 需要帶上 argument 參數 name，詳見以下 argument。 interface 透過 interface 關鍵字宣告介面。 在以下範例中 Character 是這個介面名稱，實作此介面的時候都必須包含以下三個欄位。（個人認為有點類似 OOP 的多型）。 implements 當要透過 type 實作出 interface 時，都需要透過 implements 這個關鍵字。 enum 受限的選項，常用在參數、Field Types 等。 在以下的範例中，型別為 WeightUnit 的，value 只有可能有三種可能，分別是 KILOGRAM、GRAM、POUND等。 union可以理解成 type 的集合，當今天回傳資料類型，可能包含一個以上的 type 時，union 就非常適合。 以下範例來說，會依照參數需求，來回傳需要的設備是使用手機還是電腦，這時候就很適合使用 union 回傳。 argument &#x2F; input 參數，經常使用在 query 及 mutation 中。input 是宣告 input 這個 Object Type 的關鍵字。 參數數量若大於 3 個的話，通常會包成一個 input。 Answer Reference 官網 Think in GraphQL 系列文 "},{"title":"Vue 3 學習筆記 (二)","date":"2021-12-19T13:45:06.000Z","url":"/blog/article/Vue-3-2/","tags":[["Vue","/blog/tags/Vue/"]],"categories":[[" ",""]],"content":"此篇筆記為 Vue 相關筆記第二篇，建議可先閱讀 第一篇，對 Vue 3 基礎較為熟悉後，再閱讀會更好理解。筆記部分參考 VueConf China 2021 中，VueUse 作者分享。 script setupVue 3.2 出的新功能中，包含了 script setup 這個語法糖，包含以下幾個特點： 更簡潔的 Code 優化執行效能 對 TypeScript 的支援度更好 再也不需要 return在過去 Composition API 中，template 若要使用任何 data，都會需要在 setup 中將資料 return 出來。 但使用 script setup 的語法後，引入的 state &#x2F; function 可以立即使用，不需要 return，十分方便。 提升 TypeScript 支援script setup 同時新增幾個語法，來提昇 TypeScript 支援。分別是： defineProps：定義 props 的型別 defineEmits：定義 emits 的型別 withDefaults：搭配 defineProps 賦予 props 預設值。 defineExpose因為 script setup 默認不將 component 內的 data 及 method 暴露出去。所以當如果想要在父層使用子層 dom 元素時，就可以在子 component 將該 ref 值透過 defineExpose() 暴露出去。 範例可搭配以上特色服用： 使用 script setup 後： refref 一般常用於 primitive type 的狀態使用，會在 ref() 中，放入 primitive type，像是 boolean, string, number 等等。 但其實，ref 本身也可以接受 ref 值，兩者返回的值，也完全相同。 這常用於 TypeScript 中，當今天無法確定參數的型別時，可以很方便地處理： 也因為完全相同的關係，使用上也需要特別注意，在改動其中一個 ref 值時，另一個 ref 值也會被一起更動。 unrefunref 是官方原生的 API，是一種語法糖，將以下用法包裹起來： unref 會先用一樣是官方原生的 isRef API 判定是否是 Ref，如果是的話，就將 ref 值回傳回去，如果不是的話，就直接回傳這個值。 簡單用法就如同以下，透過 unref 可以確保一定拿得到該值： 如果搭配 TypeScript，實用性也會更高： 補充，也可以搭配自定義的 MaybeRef 型別，使用上可以更簡潔： computed一般我們會透過非同步的方式取得資料後，再將取得的資料賦值給 state 或 store。但也可以先將資料透過 computed 的方式串連起來，概念跟 React 的 SWR 相似。 InjectionKey透過 provide 跟 inject 可以避免 props drilling 的問題，但對型別的支援卻不友善。這時可以透過 InjectionKey 來解決型別問題。 v-model當今天子組件接收父組件的 props 綁定 input 時，可以透過 computed 搭配 v-model 達成簡易快速的 emit。 "},{"title":"Vue 3 學習筆記 (一)","date":"2021-12-19T04:00:06.000Z","url":"/blog/article/Vue-3-1/","tags":[["Vue","/blog/tags/Vue/"]],"categories":[[" ",""]],"content":"此篇筆記是在 2021 年六月公司開新專案，導入 Vue 3 時所記錄下來的，主要參考 Kuro 大的 Vue 書籍，以及各式網路資源後所彙整。適合給過去曾寫過 Vue 2 或對 Vue 有基礎了解的人閱讀，且不會探討 Vue 底層核心運作模式。 筆記主要分成兩個章節，分別為與 Vue 2 差異，以及 Vue 3 新增的 Composition API。 與 Vue 2 差異引入方式使用 createApp： Vue Router ( v4.x )使用 creatRouter： VueX ( v4.x )使用 creatStore： 不提供全域性註冊 新增語法1. 子 component 中新增 emit 除此之外，也可以在 emits 中增加 function，處理當 emit 傳回去父層的內容，常用於驗證或是非同步操作。詳細可參考 Vue 3 官網。 2. teleport 透過 teleport 將類似 modal 視窗的 component 移動到外層的 DOM 節點上 視窗在有序 DOM Tree 中，應該是跟常用的 APP 平行，而不是被巢狀包裹在各個標籤中。但如果透過 teleport 可以將該 component 移動到指定的父層節點下。詳情可參考 官網。 3. fragment template 再也不需要根節點 在 Vue2 中，每個 template 都必需要有個根節點，但因為 Vue3 內部會將節點放進 fragment 虛擬元素中，因此不需要根節點也可以成功建立 template。 當子 component 沒有根節點包住的時候，在父層元素引入 component 時，就要特別避免以下使用： 綁定 class 綁定 v-if 綁定事件 更改語法1. v-enter &#x2F; v-leavevue 中有一些封裝好的 component 可使用，其中 transition 的 v-enter 改成 v-enter-from，v-leave 改成 v-leave-from。 2. data 必須使用函式並回傳 3. lifecycle hooks推薦直接參考 Kuro 大的 文章 4. 選取 DOM 元素Vue 2 會透過 ref，以及 this.$refs.x 存取 DOM 元素。在 Vue 3 中因為有 composition API 的 ref，因此有一點不一樣： 移除語法1. filters原先的 option API 中有 filters 的語法，但因為與 methods 的重複性很高，在 Vue3 就被移除了 2. $on、$off、$once因為 Vue3 不推薦使用 eventbus，因此移除 eventbus 中的 $on、$off、$once。 其他特性 支援 JSX 支援 TypeScript 注意事項 應避免 $ 或是 _ 開頭命名的變數名稱 composition API引入方式： setup特性： setup 相當於 beforecreate 跟 created 這兩個 lifecycle hooks。 setup 接受兩個參數，第一個是 props，第二個是 context，context 是一個 object，包含 attrs, slots, emit。因此也可以對 context 進行解構。 當今天不需要 props 只需要 emit 時，可以將第一個參數變成 _，vue 會自動忽略第一個參數。 如果今天有傳 props 時，推薦在 setup() 中把 props 當參數引入再 return 出去，這樣在 template 中引用時就可以透過 props.x 操作。未來在看 template 時可以清楚知道哪些是 props 哪些是 state\b。 以下講解的 ref、reactive、watch、watchEffect、computed 都會放在 setup 裡面。 ref資料綁定。ref 習慣會綁定的資料是原始型別，綁定後要存取資料時會透過 .value 進行存取。 reactive資料綁定。reactive 習慣會綁定的資料是物件型別，綁定後 不須 透過 .value 進行存取。 watch 資料監聽。第一個參數是要監聽的資料，第二個參數是 callback function。特別注意的是： 如果要監聽的是 ref 的值，可直接將值放入。如果是要監聽 reactive 中某個 value，需要透過 function return reactive 的值回去。 第二個參數的 callback function 中，第一個參數是改動後的新值，第二個參數是舊值。 一次監聽多個值時，第一個參數改成 array，並放入要監控的值。 範例： watchEffect實際上很少用到，跟前面提到的 watch() 有點像，不同的是不需要加入參數，而是直接監聽 watchEffect() 中有存取到的值，有更新時會執行當中的扣。 一般值在初始化的時候會執行一次，更新時會再執行一次。 computed跟原本的 vue 2 概念相同。 傳入一個 function 的時候表示會回傳一個 readonly 的 ref 值。 傳入一個 object 的時候，可設定 getter 跟 setter。 範例： custom hooks toRefs這邊要特別注意，以上的範例是使用 ref，但是當如果使用 reactive 的話，狀況會有點不太一樣，會需要多使用 toRefs： 接收 toRefs(xxx) 的值時，記得也要透過 .value 存取。 改寫 VueX使用 Composition API 後，因為資料有共通性，因此有些人推薦以 Composition API 來取代繁雜的 VueX。 Kuro 大 就曾經示範。在 Vite-demo 分支中，是使用 Composition API 共享資料，在 master 分支則是採用原 VueX 寫法。"},{"title":"透過範例理解 Hoisting 提升","date":"2021-03-21T04:12:51.000Z","url":"/blog/article/hoisting/","tags":[["JavaScript","/blog/tags/JavaScript/"],["hoisting","/blog/tags/hoisting/"]],"categories":[[" ",""]],"content":"在談 Hoisting 之前，我們先測試看看以下程式 那換種方式呢？ a 居然不是 1 而是 undefined！為什麼會這樣呢？接下來會從 ECMAScript（ECMAScript 是 JavaScript 的標準）第三版（ES3）來了解一下 JS 引擎最初是如何執行程式的。 這邊要特別注意一下，var 跟 let const 的 hoisting 狀況不太一樣，這邊指的都是 var。 執行模型JS 在執行程式前的編譯階段時，會先將整份檔案視為一個 Global Execution Context ，中文名是全域執行環境，簡稱 Global EC，並把 Global EC 放入 stack 中。 接下來開始依序從第一行開始掃，在全域（Global）的環境碰到變數時，會先將變數初始值設成 undefined 後放入 Variable Object（以下簡稱 VO）。碰到函式宣告時，也會將函式放入 VO，key 為函式名，value 為 function，如果函式宣告時包含參數，參數會放進該函式類似 VO 的 Activation Object（以下簡稱 AO），並將函式視為一個 Execution Context，push 進 stack 中。 進入函式的 EC 時，一樣從函式第一行開始掃，如果發現有宣告變數，就會放入該函式 AO，一樣將變數初始值設成 undefined 。以底下例子為例： 步驟如下 建立 global EC 並 push 進 stack 第一行宣告變數 foo，放入 global EC 的 VO，並給予初始值 undefined 第二行宣告變數 a，放入 global EC 的 VO，並給予初始值 undefined 第三行宣告函式 bar，放入 global EC 的 VO，給予初始值 function。建立 bar EC 並 push 進 stack。發現宣告參數 a，將參數 a 放入 bar EC 的 AO，給予初始值 undefined 第四行沒有發現宣告，不做事 第五行宣告變數 a，但發現 a 已經存在 bar EC 的 AO 裡，因此不做事 第六行沒有宣告，不做事 第七行沒有宣告，不做事 第八行沒有宣告，不做事 第九行沒有宣告，不做事 第十行呼叫函式 bar，且參數是 4，更改 bar EC 的 AO，a 從 undefined 變成 4 編譯後的成果類似下圖： 特別注意以上都是編譯的結果，程式都還沒執行，程式開始執行時，實際步驟類似如下 程式執行後，會變成 因此執行過後結果是： 如果第五行跟第七行對調，這時候答案就會變了 了解執行模型後，回過頭來看剛開始的題目，其實就可以很清楚的了解，為什麼 a 是 undefined 而不是報錯 a is not defined。 優先順序從上面可以知道，var 宣告的變數、函式及函式內的參數等都會被提升，那當今天這三個都同名時，誰會優先被提升呢？ 所以優先順序是：&#x3D;&#x3D;函式 &gt; 參數 &gt; var 宣告的變數&#x3D;&#x3D;。而當今天有兩個同名的函式時，後者會覆蓋前者 練習 答案在底下，請先練習 ＝＝＝＝＝＝＝ 防雷線 ＝＝＝＝＝＝＝＝＝ undefined 7 8 30 30 1 70 報錯 b is not defined TDZvar 相關的 hoisting 都了解後，現在可以來了解前面說跟 var 有點不一樣的 let const。先從範例來看： 跑完會報錯，感覺很像是 let 沒有提升，不過如果 let 真的沒有提升，應該會存取到 global scope 的 a = 1 才對。 特別的就在這， let 跟 const 其實也會被提升，只不過宣告的變數，不會被初始化為 undefined，可以想像成 VO 裡有這個變數名稱的 key，但 value 是空的。因此在賦值之前試著存取該變數，都會出現錯誤。 前面有說過 let 跟 const 都是以大括號的 block 作為作用域，所以只要該 block 中有存取未宣告的變數，從進入 block 到賦值前，就會是 Temporal Dead Zone（TDZ），中文為暫時性死區，是一個為了解釋 let 與 const 的 hoisting 行為所提出的一個名詞。舉例來說： 資料來源 我知道你懂 hoisting，可是你了解到多深？ 推薦閱讀 function exprestion 的初始化 "},{"title":"CSS 效能優化","date":"2021-03-19T15:04:23.000Z","url":"/blog/article/css-performance-optimization/","tags":[["CSS","/blog/tags/CSS/"],["gzip","/blog/tags/gzip/"],["sprites","/blog/tags/sprites/"]],"categories":[[" ",""]],"content":"效能優化一直是個博大精深的主題，這邊簡單討論幾種方式，包含像是資源大小、載入方式及執行方式。 資源大小進行文字資源優化，優化後檔案變小，當然傳輸時間就會縮短。 Minify 最小化在原本的 CSS 檔案當中，為了易讀性時常會有空格跟換行，Minify 就是將原本的檔案當中的空格、換行、註解全部拿掉，這樣檔案大小會縮小，但瀏覽器依然可以成功解析。 透過 Sass 內建的指令就可以達成（壓縮過的副檔名通常都是 min.css）： 或是透過 VS code 的 Live Sass Compile 也可以達成。 GzipGzip 就是壓縮，可以想像成一般我們常見的 zip 或是 rar 壓縮檔。在 Modern Web 現代化網頁開發設計中，大多瀏覽器都已經可以自動要求壓縮檔，並在渲染時自動進行解壓縮。若要求不到壓縮檔時才會存取原始檔案。 因此 Server 有沒有設定啟用讓 Gzip 壓縮檔案就很關鍵，像部署的 AWS EC2，預設模式就是會透過 Gzip 壓縮檔案。透過 Gzip 壓縮是最簡單且效率最高的優化方式。 更多文字資源優化可參考 最佳化文字資產的編碼和傳輸大小 - Google。 載入方式Critical Css把重要的資訊先渲染出來，讓使用者可以先收到一些資訊，其餘的再依序載入。 做法就是直接在 HTML &lt;head&gt; 中，直接把重要的 CSS 寫入&lt;style&gt;，其餘的再打包成一個檔案引入。這樣當瀏覽器在渲染出 HTML 檔案時，直接套用 CSS 樣式，不需要再發一個 request 到 CSS 檔案。 透過 Critical Css 優化效能最被人詬病的一點，就是不好維護，因為資料散落在不同地方。這時候可以參考 這篇文章，裏頭討論如何透過基於 Node.js 的第三方套件 Grunt 來達成自動化 Critical Css。 Css Sprites是圖片最佳化的一種方式，大多運用在 icon 上。因為每個 icon 都是一個圖片檔，當今天一個網站可能有數十個甚至數百個 icon 時，就會有多少個 request，非常耗效能。 不如將圖片全部組合成一張圖片，瀏覽器只要載入一張大圖，再透過 CSS 的 background-position 屬性去做切割，只取需要的部分，就可以達成跟原先一樣的效果。 gulp 跟 webpack 都有提供將圖片合在一起，變成一張 Sprite 圖的服務。關於 Sprites Css 詳細可參考 這篇，裡面也有討論另一種圖片最佳化 ─ base64。 Cache可參考之前寫的 快取 Cache 是什麼？那些網頁前端的快取（上），以及 快取 Cache 是什麼？那些網頁後端的快取（下）。 執行方式在了解如何從 CSS 的選擇器及屬性渲染進行優化前，先來看 CSS 渲染方式，以及 HTML 是怎麼被渲染的。 瀏覽器如何渲染檔案今天瀏覽器載入 HTML 的時候，會依照 HTML 的標籤元素依序製造出 DOM ( Document Object Model )。 假設是上方範例的文件，會是這樣的依序建立： 而當瀏覽器解析到 &lt;head&gt; 裡的 &lt;link&gt; 時，就會發 request 給該檔案，瀏覽器收到 response 後，也會開始製作 CSSOM ( CSS Objext Model )。 當瀏覽器在製作 CSSOM，別忘了它也同時在渲染 DOM，兩者是並行執行的。 當 DOM 跟 CSSOM 都渲染完後，瀏覽器就會將兩個合併，變成「轉譯樹狀結構（Render tree）」： 若今天在某個 div 的 css 上加上 display: none，那這個 div 就不會在 Render tree 上呈現。 有了 Render Tree 後就可以開始進行版面計算及配置，並開始繪製網頁跟渲染。步驟如下： 處理 HTML 標記，產生 DOM 樹狀結構。 處理 CSS 標記，產生 CSSOM 樹狀結構。 將 DOM 樹狀結構和 CSSOM 樹狀結構合併為 Render tree。 對 Render tree 進行版面配置，計算每個節點的幾何形狀。 在螢幕上繪製各個節點。 以上圖片及部分文字均源自 Google。 選擇器簡單來說就是將低選擇器的複雜度。舉例來說： 因此 CSS Class 建議以 BEM 的命名方式，這樣可以直接下 .list__list-item &#123; &#125; 直接選到該元素。更多可參考 Google 文章。 屬性渲染其實在前面討論瀏覽器如何渲染頁面時，第四及第五點： 對 Render tree 進行版面配置，計算每個節點的幾何形狀。 在螢幕上繪製各個節點。 其實還可以更仔細的去區分成五個步驟，這樣的流程被稱為 Brower Rendering Pipeline。步驟分別是： JavaScript：利用 JS 來處理視覺變更相關的工作，像是一些動畫、新增 DOM 元素、轉換等。CSS 動畫、轉換和網頁動畫 API 也是從這個階段開始。 Style 樣式計算：根據符合的選取器，弄清楚 CSS 規則適用於哪些元素。 Layout 版面配置：排版。計算元素要佔用的空間及在螢幕上的位置。如：width、height、position、margin、padding。 Paint 繪製：描繪文字、顏色、影像、邊框和陰影，如：box-shadow、border-radius、color、background-color、text-shadow。這階段耗時最長，應儘量避免。 Composite 合成：合成所有元素及圖層。如：transform、opacity。 當然瀏覽器在第一次載入渲染網頁時，每個步驟都需要跑過，不過後來的像是切換顏色、背景、邊框等不影響版面配置的動作，瀏覽器會跳過前面幾個步驟，直接進行 Paint；切換 transform 或是 opacity 時，也是直接進行 Composite。 因此這就是可以做效能優化的地方了，&#x3D;&#x3D;當我們可以從第四、第五步驟開始做的時候，就不需要讓瀏覽器從第三步驟開始執行&#x3D;&#x3D;。 最常見的例子就是當我們希望某個元素可以改變位置時，不要使用 position，因為 position 會影響版面位置，讓瀏覽器必須從第三步開始做起，而是改用 transform: translate();，直接做第五步。 資料來源： 關鍵轉譯路徑 Critical Rendering Path ─ Summer 桑莫 Browser Rendering Optimization ─ TechBridge Rendering Performance Overview ─ Google 推薦閱讀 圖片最佳化（Image Optimization） ─ Summer 桑莫 如何做圖片壓縮？ ─ Summer 桑莫 文字資源優化 ─ Summer 桑莫 從 CSS sprite 進化到 SVG sprite "},{"title":"快取 Cache 是什麼？那些網頁後端的快取（下）","date":"2021-03-14T06:24:28.000Z","url":"/blog/article/cache-2/","tags":[["cache","/blog/tags/cache/"],["CDN","/blog/tags/CDN/"],["Proxy Server","/blog/tags/Proxy-Server/"]],"categories":[[" ",""]],"content":"上一篇介紹了什麼是快取，也簡單了解了網頁 Client-side 的快取，想了解的可以點選 快取 Cache 是什麼？（上） 認識。 在這篇當中會簡單談 Proxy Server 代理伺服器的快取，以及網頁 Server-side 的快取。 Proxy Server 代理伺服器，也稱為前向代理 代理伺服器顧名思義就是一個代理人的概念，介於 client 端跟 server 端的中間人，需要由 client 端設定。做的事情包含： 代理 client 發送 request 連接網際網路 將資料存在自己的快取 收到 server 的 response 並回覆給 client 也因為 Proxy Server 這個中間人的關係，所以間接形成一個防火牆，當外部要攻擊 client 端時，就會攻擊到 Proxy Server，因為所有請求的 IP 位址都是 Proxy Server。 一般來說常見的架構是，多個 client 對應一個 proxy server。在這樣的狀況下，當 client A 請求過 R 網站，隔天 client B 也想要請求 R 網站時，proxy server 就會依照快取的設定檢查有無過期後，直接從快取拿資料回傳給 cient B，達到降低負載的效果。 但一旦請求太多，proxy server 也是有可能會有應付不來的可能，這時候就可以考慮幫 proxy Server 設置他的上層代理伺服器（類似幫這個 proxy server 再開幾台 proxy server 的概念），詳細可以參考 鳥哥的文章。 Proxy Server 特色包含： 因為快取加快網頁存取速度、減少網路頻寬浪費 提供類似防火牆功能保護 client 搭配上層代理伺服器可達成降低負載（Load Balance）的效果 Proxy Server 雖然好用，但有幾個致命的缺點： 因為隱藏 client 的 IP 位址，可能會被濫用做壞事 由使用者設定，對一般大眾門檻太高。且因設定不易，可能會因為快取機制拿到舊資料 因此就誕生了 CDN。 CDN Content Delivery Network，內容傳遞網路 Reverse Proxy在討論 CDN 之前，要先來談談反向代理伺服器（Reverse Proxy），因為 CDN 是反向代理的應用之一。那什麼是反向代理呢？其實很多概念跟 Proxy Server 類似，最大的不同就是，反向代理的人並非 client，而是 Server。 反向代理的特色包含： 一般大眾使用門檻低：因為由 server 端進行設定，所以使用者不須做任何設定 保護 Server：跟前向代理（proxy server）相反，因為接收 response 的 IP 位址都是反向代理的，所以外部要攻擊 server 的難度提升不少 壓縮內容以節省網路頻寬 保留前向代理的優點： 提供快取加快使用者存取速度 降低伺服器負載 運作特色CDN 的概念就向是 Server 端將反向代理伺服器放在各個地方，降低原先 client 發送 request 到距離更遠的地方時，可能產生的網路連接及交換問題。 除了 反向代理原本的特色外，CDN 特色還包含： 提高傳輸效能：CDN 可以依照使用者的位置連接距離最近、最順暢的反向代理 提高系統穩定性： 當某個反向代理伺服器遭到攻擊時，CDN 就可以將 request 連接到其他的反向快取，繼續提供服務 Server 當機時，也因為 CDN 的快取機制讓使用者不至於都無法連線 注意要點Server 端在設定 CDN 的快取有效時間，跟 CDN 回覆給 client 端的快取有效時間需要一致，否則會發生資料不同步的事情。可參考 網路傳輸的加速 - CDN 與 HTTP 緩存。 Server-SideServer-Side 的快取有很多種，這邊主要談的是 Object Cache，類似資料庫的快取，而眾多資料庫快取當中，這邊只會簡單介紹 Redis。 RedisRedis 是 in memory 的 key-value 資料庫，位置在 Web Server 跟 DB 中間。因為 DB 的資料都存放在磁碟或 SSD 上，而 Redis 資料都位於記憶體內，有了 Redis 之後，可以省去存取磁碟的麻煩、避免搜尋時間延遲，並在幾微秒的時間內存取資料。 資料來源 網路傳輸的加速 - CDN 與 HTTP 緩存 反向代理 CDN "},{"title":"快取 Cache 是什麼？那些網頁前端的快取（上）","date":"2021-03-14T06:10:03.000Z","url":"/blog/article/cache-1/","tags":[["cache","/blog/tags/cache/"],["HTTP","/blog/tags/HTTP/"]],"categories":[[" ",""]],"content":"中文是快取，中國翻作緩存。簡單來說就是把資料暫時存在一個地方，以快速讀取資料。 快取剛開始其實指的是硬體的 CPU 快取，後來衍伸出只要是類似可快速存取的應用，就可被稱為快取。其中包含但不限於網頁 Client-side 及 Server-side 的快取，以及 Proxy Server 代理伺服器的快取。 因為應用範圍很廣，此篇會先介紹網頁 Client-side 的快取。想了解 Proxy Server 代理伺服器的快取，以及網頁 Server-side 的快取，可以點選 快取 Cache 是什麼？（下）。 Client-side Cache前端相關的快取有很多種，這裡介紹的快取因為建立在 HTTP 運輸協定，因此也被稱為 HTTP Caching，都跟瀏覽器相關。 種類依照快取優先順序分為以下四種： Memory Cache： 最優先 部分瀏覽器才有，包含但不限於 Chrome 存放在記憶體的快取 該頁籤關閉就後，快取就會消失 F5 刷新網頁時大多都是從這裡快取資料 相較 Disk Cache： 存取速度快 可存放的容量較小 Service Worker Cache 僅次 Memory Cache 優先的快取 需要安裝 Service worker 才可使用 只限 HTTPS 協定 即便 Service worker 沒有該資料的快取，但只要透過 Service worker，即便是從之後的 Disk cache 拿，都會顯示是從 Service worker 拿到的快取 快取持續性長，關閉瀏覽器及頁籤後還可持續留存 Disk Cache &#x2F; HTTP Cache 存放在磁碟的快取 Client-Side Cache 大多都是 Disk Cache 即便頁籤或是瀏覽器關閉，快取也不會消失 相較 Memory Cache： 存取速度較慢 可存放的容量較大 Push Cache 基於 HTTP&#x2F;2 的 Session Session 結束快取也跟著消失 以上三種都沒有才會被使用 （實在是不了解 Push cache QQ 以上的優先順序如下圖（省略了部分瀏覽器才有的 Memory Cache）：圖片來源 使用設定HTTP Caching 除了 Service Worker 之外，其他都是透過 Server 端的 HTTP Response Headers 來設定，所以其實只要 Server 端寫好設定，瀏覽器就會自動依照設定做相對應的運作。以下設定方式是針對 Memory Cache 及 Desk Cache，並依照三種概念區分，分別是使用與否、有效期限及驗證。 使用與否 不要使用： Cache-Control: no-store：每次都發 request 到 Server 請求檔案 要使用： Cache-Control: public：可被瀏覽器及中間的代理伺服器（Proxy Server）或是 CDN 快取 Cache-Control: private：只可被瀏覽器快取 Cache-Control: no-cache：每次都確認看資料有沒有變動更新。通常會搭配以下討論到的 ETag 或 Last-Modified 使用 Pragma: no-cache：跟 Cache-Control: no-cache 效用相同，但基本上不會使用，是古老的 header。 有效期限 Cache-Control: max-age=60：有效期限是收到 response 後 60 秒，假設 30 秒刷新頁面時，並不會跟 server 拿資料，而是從快取。是相對時間。 Cache-Control: s-maxage=60：針對 proxy server 代理伺服器，像是 CDN 所設定的有效期限。如果 30 秒時 CDN 的快取內容有變，瀏覽器也不會發送 request。是相對時間。 expires: Wed, 21 Oct 2020 07:28:00 GMT：絕對時間，該時間後就無效。 三者優先權： Cache-Control: s-maxage &gt; Cache-Control: max-age &gt; Expires。 驗證當快取過期時，不代表不能用快取裡的資料了，這時候就可以透過以下來跟 Server 確認，快取裡的資料是不是還可以使用。 驗證方法有兩種： 依照修改時間：Last-Modified 與 If-Modified-Since 依照檔案有無變動：Etag 與 If-None-Match 依照修改時間Server 設定的 Response Headers： 當一分鐘過後，快取已經過期時，使用者刷新瀏覽器時，瀏覽器會發送以下的 Request Headers： 如果檔案不變時，Server 就會回覆： 如果檔案有改變，Server 就會回覆： 依照檔案有無變動Etag 的概念有點類似 Hash，只要是同樣的輸入，一定會得到相同的輸出，Etag 也是。如果檔案內容沒有變動，Etag 的值也會是相同的。 Server 設定的 Response Headers： 當一分鐘過後，快取已經過期時，使用者刷新瀏覽器時，瀏覽器會發送以下的 Request Headers： 如果檔案不變時，Server 就會回覆： 如果檔案有改變，Server 就會回覆： 一般來說，&#x3D;&#x3D;會使用依照修改檔案與否的 Etag 與 If-None-Match&#x3D;&#x3D;。因為有可能檔案從 A 改成 B 又改回 A，這樣依照編輯時間是有被改過的，還是會需要下載一遍相同的檔案。 常見使用類型 頻繁更動的資料：cache-control: no-cache 搭配 etag 可以將 etag 的機制實作在 JS 檔案名稱，讓 JS 檔案。在 index.html 當中 &lt;script src=&quot;檔名有變動&quot;&gt;&lt;/script&gt;，index.html 的 etag 就會改變，這時就會只需要 不常變化的資料：cache-control: max-age=31536000 （一年） 希望檔案有更新，再發 request，可以將樓上兩者搭配使用。比方說在 index.html 設定 cache-control: no-cache 搭配 etag，而 index.html 裡 &lt;script src=&quot;script-qd3j2orjoa.js&quot;&gt;&lt;/script&gt;，將 etag 機制直接放入檔案名稱，檔案一有更改是直接更改檔名。JS 檔設定 cache-control: max-age=31536000。這樣一來，一旦 JS 檔名更改，index.html 的 etag 也會更改，就可以達成目的。 失效當瀏覽器發出 PUT、POST、DELETE 等請求時（要更改、新增、刪除資料時），原先該 URL 的各種 Client-side 快取就會自動失效。 強迫瀏覽器更新資源 打開 dev tools 的 Network 標籤，勾選 Disable cache 後，再重新按重新整理 Ctrl + F5 &#x2F; Ctrl + 按重新整理 資料來源 深入理解浏览器的缓存机制 循序漸進理解 HTTP Cache 機制 Web 快取 HTTP Caching – Summer HTTP 快取 "},{"title":"常見的網站攻擊方式","date":"2021-03-11T07:51:12.000Z","url":"/blog/article/attack/","tags":[["資訊安全","/blog/tags/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/"],["XSS","/blog/tags/XSS/"],["SQL injection","/blog/tags/SQL-injection/"],["CSRF","/blog/tags/CSRF/"]],"categories":[[" ",""]],"content":"在討論常見的網站攻擊方式之前，可以先認識一下 OWASP。 Open Web Application Security Project OWASP 是一個線上社群，介紹了各種不同的網路安全問題、每幾年的十大安全問題排名跟範例，完全免費，基本上是所有做資訊安全的聖經。 推薦 techbridge 的 這篇文章，講了 2010 及 2013 的前十大網站攻擊排行，以及 這篇 是官方在 2017 年十大攻擊手法的中文版本。 XSS Cross-Site-Scripting，俗稱 JavaScript Injection，中文被翻成跨站式腳本攻擊或是跨站攻擊。 XSS 是在使用者可操控的地方，像是留言內容、帳號名稱等地方，惡意寫入程式碼，讓網站載入這些內容時，一起執行這些程式。 常見的可能就是透過插入一個圖片，圖片會自動訪問 hackerhome 上的 grabber.jsp，並將使用者的 cookie 作為 msg 的值，讓受害者的 cookie 遭盜用。 所以要做的事情，就是防範讓伺服器知道這並不是程式碼，而只是一般的文字。可以透過 php 內建的 htmlspecialchars 達成這件事。 但要特別注意的是，並不是像 hash 一樣，在輸入密碼後就馬上處理並將 hash 過的內容存在資料庫，而是儲存原本的字元在資料庫，輸出時再經由htmlspecialchars 轉化。因為輸入防不勝防，直接解決輸出才能打到痛點。 utils.php index.php 儲存型 stored XSS，或被稱為 persisted XSS 以輸入惡意、並會儲存到資料庫的資料方式攻擊，這種稱為儲存型 XSS，也就是前面提到的攻擊方式。 一般多以這種攻擊方式，因為這種攻擊方式的網址正常，只要成功攻擊，一般使用者只要點入就很有可能被竊取資料、或是被轉到其他網站。 反射型 Reflected XSS 反射型是利用有些網站會將 query string 的內容，直接顯示在螢幕上作為提示文字，竄改 query string 的內容，將惡意程式碼放入 query string 達到攻擊目的。 但這種方式需要刻意讓使用者點選帶有奇怪程式碼的網址，所以一般比較少見。 DOM XSS DOM-Based XSS（基於 DOM 的 XSS 類型） 透過程式碼當中 DOM 節點的 .html 或是 .innerHtml 漏洞，即可輸入 HTML 標籤，也就是可輸入 &lt;script&gt; &lt;img&gt; 標籤，將惡意程式碼帶入。 跟前面兩種 XSS 攻擊手法比較不一樣，前面兩種主要防範方式都是從後端，但 DOM XSS 從前端就可以簡單防範，直接看範例： 如果沒有檢查輸入，輸入可填入以下內容即可輕鬆執行程式碼。 解決方法其實很簡單，只要把 .html 或是 .innerHtml 都改成 .text 及 innerText 就可以了。 SQL Injection 被譯為 SQL 注入或是 SQL 隱碼 SQL Injection 一直是 OWASP 的常勝軍。使用的原理也相似，都是透過原本應該輸入文字或帳密等欄位，輸入了程式碼進去。 跟 XSS 不一樣的是，SQL Injection 是輸入 SQL 的語法，而 XSS 多半是輸入 JS 及 HTML 的語法。 一個有會員登入功能的網站，都會需要輸入帳號與密碼來進行驗證。而後端程式，如 PHP 就必需支援相關的登入檢查，判定 User 輸入的帳號、密碼是否正確，來確定登入是否成功。 但若是駭客輸入有特殊字元的帳號：「 ‘ or 1&#x3D;1 &#x2F;* 」，密碼：「任意值」，這時 SQL 語法就會變成： 這時候可以透過 MySQL 內建的語法 Prepared Statements 來解決這個問題。 add.php login.php 幾件事情要注意： 只要有 SQL 語法都要改成 prepared statements。 透過 bind_param() 拼接時記得第一個參數，如果要拼接三個字串是 &#39;sss&#39;; 第一個是字串第二個是整數第三個是字串是 &#39;sis&#39;。 CSRF Cross Site Request Forgery，跨站請求偽造 假設我們今天登入 A 網站後沒有自行登出，A 網站會透過 Cookie 記住身分，讓我們下次進入網站的時候不需要再登入一次。但駭客其實可以透過這點，讓你誤點選設計好的 B 網站，透過在進入 B 網站時自動發送假的 request 到 A 網站，A 網站的 Server 端會以為這是我們本人發送的，就可以成功執行 request。 舉例來說，假設我們今天登入了 mybank.com 網站後沒有登出，只要有心人士惡意讓我們點了 myvideo.com 網站： 如果網站沒有做其他驗證的話，其實很有可能就可以直接轉帳出去了。 Double Submit Cookie駭客跟使用者是使用不同的網域，也就是說駭客沒有辦法設定該網域的 Cookie，所以其實可以透過這一點來防範這件事。 由 client side 來生 CSRF token，並且把這個 CSRF token 放進表單及 Cookie 中，在收到 request 的時候 server 再去比對是否有值且相同。 但這還是有可能會遭到破解，如果駭客進入到了子網域中，根據 Cookie 設定規範，子網域能夠存取父網域的 Cookie，還是有可能可以成功被破解。 Samesite瀏覽器本身就有提供防範 CSRF 的機制，而且很簡單。只要在設定 Cookie 的時候多加一個 SameSite 就好了，用意是讓 Cookie 只允許 same site 使用，不應該在任何的跨網域的 request 被加上去。 透過瀏覽器設定的方式是目前最推薦的做法，Lax 與 strict 的差別，及更詳細資訊可參考 這篇文章，這邊的筆記也都是參考此篇文章的。 有趣的測試小遊戲這幾個遊戲都是讓你練習該如何學習駭客透過 XSS 及其他方式執行程式碼。  (解題影片)  (可能會被 chrome 擋下來，可以試著用其他瀏覽器玩)  資料來源 【網頁安全】給網頁開發新人的 XSS 攻擊介紹與防範 SQL Injection 常見的駭客攻擊方式 補充資料 前端安全系列（一）：如何防止 XSS 攻击？ 一次看懂 SQL Injection 的攻擊原理 "},{"title":"密碼保護","date":"2021-03-11T07:40:23.000Z","url":"/blog/article/password/","tags":[["資訊安全","/blog/tags/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/"],["加密","/blog/tags/%E5%8A%A0%E5%AF%86/"],["雜湊","/blog/tags/%E9%9B%9C%E6%B9%8A/"],["編碼","/blog/tags/%E7%B7%A8%E7%A2%BC/"]],"categories":[[" ",""]],"content":"當我們把帳號密碼都存在資料庫當中，有個最大的隱憂就是，一旦資料庫遭駭，駭客就可以拿到所有的帳號密碼，造成資訊安全上的危害。 以下簡單簡介常見的幾種密碼保護方式： 編碼 編碼，encode；解碼，decode 編碼並不會修改資料、也沒有任何加密的效果，單純就是換個方式來表達資料而已。最常見的就是摩斯密碼。 對資訊安全，一點幫助都沒有。 加密 加密，encryption 資料加密之前叫做「明文 plaintext」，加密之後叫做「密文 ciphertext」。「加密」是明文變密文，「解密」是密文變明文。 加密有幾個特性： 加密是一對一的關係，也就是說密文在固定加密演算法下，只會對應到一個明文。因而衍伸加密的重要特性，可以解密。 需要密鑰 (key) 才可以進行加密及解密。 分為對稱加密及不對稱加密。 對稱加密只會有一把密鑰。常見的對稱加密法是 AES。 不對稱加密會有兩把密鑰，一把公鑰 ( public key ) 一把私鑰 ( private key )，公鑰負責加密，私鑰負責解密。常見的不對稱加密法是 RSA。 雜湊 雜湊，Hash function，又稱雜湊函式或是雜湊演算法 雜湊有幾個特性： 是單向函式 &#x2F; 演算法，不能從輸出還原出原本的輸入。 同樣的輸入經過雜湊後，一定會得到同樣的輸出。 不同長度的輸入，會得到固定長度的輸出。 類似鴿籠原理，因為是固定長度的輸出，所以不同輸入可能會產生同個輸出。這樣的情況稱為碰撞 Collision。但一般知名的雜湊發生碰撞的機率很低。 通常會加鹽 (salting)。加鹽通常會自動幫使用者產生一段亂碼，可以穿插放在雜湊前中後，有資安概念的可能會每個人都加上一樣的鹽，厲害點的可以每個人的鹽都不同。一般鹽會由亂數產生，然後把鹽也存在資料庫中，這樣就能有更高的防範， 常見的雜湊演算法: MD5 （ 已被證實不安全 ） SHA-1 （ 已被證實不安全 ） SHA-256 （ 比 MD5 還強、安全性更高的雜湊函數，但對於伺服器來說，越安全、也代表速度越慢 ） 但雜湊也不是說不能解，其實就有一張彩虹表（rainbow table），用原本已經做好字串與雜湊值對照的表格，去強硬破解資料庫裡的密碼。所以由此就可以知道加鹽的重要性。 加密及雜湊兩個在資訊領域中，都是對資料的處理方法，兩者最大的差別就在於 加密可以進行解密（可逆），但雜湊不行還原（不可逆）。 除此之外， hash 也常用在檢查檔案的完整性，許多軟體會提供 hash 過後的文字（校驗碼），讓使用者下載過後可以自行驗證檔案是否有被更改或加料過。 資料來源 [BE101] 用 PHP 與 MySQL 學習後端基礎 一次搞懂密碼學中的三兄弟 — Encode、Encrypt 跟 Hash [第十一週] 資訊安全 - 為什麼密碼要經過雜湊 ？ 推薦閱讀 How Dropbox securely stores your passwords "},{"title":"JavaScript 資料型別","date":"2021-03-09T15:29:02.000Z","url":"/blog/article/%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5/","tags":[["JavaScript","/blog/tags/JavaScript/"]],"categories":[[" ",""]],"content":"JavaScript 資料型別有七種，又分為原始型別及物件型別。 介紹原始型別有六種： Boolean 布林，例如：true、false Null 空值 Undefined 未定義 Number 數字，例如：12345 String 字串，例如：&#39;Hello World&#39; Symbol（ES2015 新增） 符號 其他的都是物件型別： Object 物件，包含（物件 Object、陣列 Array、函式 Function、時間 Date…） 辨別方式可以透過 typeof 來辨別型別 註：typeof null 是一個在 JavaScript 剛推出時就存在的 bug，因為擔心改動後會導致太多網站壞掉，所以目前及未來都沒有改的計畫。 仔細看會發現，確實像是時間、陣列都會被辨別為物件，雖然畢竟當初分類就是這麼分的，但在實務使用上還是有點不方便，因此其實有其他方式可以更準確地達到實務上的需求 ─ Object.prototype.toString.call(...) 。 原始型別 VS 物件型別可否更改原值原始型別只能重新賦值，不能更改原值，比方說 物件型別可以更改原值，比方說 變數存放方式之所以會有這樣的差別，最大的差別就在於變數存放的方式。可以想像成變數名稱都是一張 memo 紙，而變數是一個箱子。 在原始型別當中，寫著變數名稱的 memo 紙貼著的箱子裡，放的就是變數的值，但在物件型別當中，寫著變數名稱的 memo 紙貼著的箱子裡，放的是一個記憶體位置，記憶體位置中放的才是變數的值。 綜合以上，我們會稱 &#x3D;&#x3D;物件型別是可變的 mutable，原始型別是不可變的 immutable&#x3D;&#x3D;。 &#x3D; 與 &#x3D;&#x3D; 與 &#x3D;&#x3D;&#x3D; =：賦值 ==：兩邊進行比較，且會自動進行型別轉換 ===：兩邊進行比較，但不進行型別轉換 因此在比較時，永遠都是用 === 最可靠。關於更多的 == 與 === 比較可參考這個 好懂表格。 另外，NaN 不大於、小於、等於任何數字或是 NaN，NaN 與任何數字運算也都會變成 NaN 。"},{"title":"變數宣告，var、let、const 的差別","date":"2021-03-09T15:25:14.000Z","url":"/blog/article/%E8%AE%8A%E6%95%B8%E5%AE%A3%E5%91%8A%EF%BC%8Cvar%E3%80%81let%E3%80%81const-%E7%9A%84%E5%B7%AE%E5%88%A5/","tags":[["JavaScript","/blog/tags/JavaScript/"]],"categories":[[" ",""]],"content":"變數宣告方式有三種，分別是 var、以及 ES6 新增的 let 及 const。 var 跟 let const 最大的差別在於作用域，也就是變數的生存範圍。 在 ES6 之前 var 是以函式 function 為一個作用域，因此稱為 functional scope。而 ES6 之後是以 block 為一個作用域（大括號，像是任何迴圈、條件式等），稱之為 block scope。比方說： var如同前面所說，var 是 function scope，但如果 var 不在 function 裡宣告時，會變成全域變數（global variable），也就是整個檔案都存取的到，沒有作用域之分。 像案例 C 這樣從 test scope 找 a 變數，找不到往外找找到 global scope 的方式，被稱為 scope chain（範圍鍊）。 向案例 F 這樣不使用 function，而是使用條件式時，還記得之前說過 var 除了使用 function 時才有作用域的區別，因為這樣改到 global 原先值的情況，被稱為 &#x3D;&#x3D;變數汙染&#x3D;&#x3D;。 但要特別注意以下情況： 以上很容易會以為印出來的值是 &#39;inner&#39;，不過其實跟函式在哪裡呼叫沒有關係，在設計該 function 時就已經決定好了該變數的 scope chain。不過如果改成以下，把最終的 function 放入： 在上面的例子當中，如果 inner scope 跟 change scope 都沒有宣告 a，那麼找尋的歷程就會是： let &amp; constconst 代表的其實是 constant（常數），也就是不會變的數值。因此let 跟 const 最大的差別就在於 let 宣告的變數可以再重新賦值或更改，但 const 不行。 以上用 let 都沒有這些問題，不過要特別注意： "},{"title":"什麼是 prototype ?","date":"2021-03-09T12:52:49.000Z","url":"/blog/article/prototype/","tags":[["JavaScript","/blog/tags/JavaScript/"]],"categories":[[" ",""]],"content":"前言在 ES5 的 JS 物件導向中，function 被當成建構子以及 class 用，因此被稱為構造函數。構造函數可透過語法 new 建造一個 instance 實體，也可以透過 prototype 做出共用的 method 方法： 不過 JS 是如何知道 calculateA.input 等同於 calculateB.input 的呢？或者可以換個問題，JS 是如何繼承 method 跟 property 的呢？ 透過 __proto__ __proto__當我們建造 instance 時，JS 會自動幫我們在 instance 加上 __proto__ 這個屬性，讓 instance 要使用該 method 找不到時，可以循著 __proto__ 連結，往上找到有這個 method 的 prototype，以上面的例子來說，有點類似這個概念： 像這樣不停往上找，從 這個透過 __proto__ 尋找的過程，被稱為 prototype chain 原型鍊 。 驗證以下介紹三種方式驗證原型鍊： &#x3D;&#x3D;&#x3D;一、透過 === 值得注意的是，不只有建構式的 prototype 才有 __proto__，建構式本身也有 __proto__。 以上面的例子來說，Calculator 這個建構式的 __proto__會連接到 Function.prototype。 Function.prototype 的 __proto__ 則連接到頂層的 Object.prototype。 仔細想想其實一切都很合理，Calculator 本來就是 Function，連接到 Function 很正常；而 Function 本來就是 Object，連接到 Object 也很正常。可以想像成以下這樣 hasOwnProperty二、 透過 hasOwnProperty instanceOf三、 透過 instanceOf如果 A instanceOf B A 是 B 的實體的話，會回傳 true。 constructor其實每個的 prototype 底下，除了共用的 method、property 以及 __proto__ 外，還有一個叫做 constructor 的屬性。 在前面我們透過 instanceOf 驗證原形鍊時，得知不只是 new 創建出來的 instance 才是 instance，像是 constructor 也是 Object 的 instance。 所以相反的，Object.prototype 底下的 constructor 屬性也是 Object，因為他們自己就是建構式，可以 new 出 constructor。當然 Calculator.prototype.constructor = Calculator ，因為 Calculator 本身就是 constructor 拉，他的 constructor 也自然指向自己。 因此任何 X.prototype.constructor = X 。 new了解原型鍊後就容易理解 new 是如何運作的，其實他幫我們做的步驟如下： 創建一個空物件（以下簡稱 O），將 O 當成是 new 出來的實體 透過 __proto__ 讓 O 跟建構函式產生連結 將 O 當成建構函式裡的 this 並透過 call 或 apply 執行建構函式 回傳 O "},{"title":"關於我","date":"2024-02-13T10:02:10.762Z","url":"/blog/about/index.html","categories":[[" ",""]],"content":"關於我我是 Yu，在台灣的網頁前端工程師。 喜歡旅行、爬山、看書和追劇，關注環境保護及人權，在這主要分享個人學習筆記，內容如有任何錯誤歡迎指正。 "},{"title":"標籤","date":"2021-03-13T15:10:26.000Z","url":"/blog/tags/index.html","categories":[[" ",""]]},{"title":"搜尋本站","date":"2021-03-13T15:02:34.000Z","url":"/blog/search/index.html","categories":[[" ",""]]},{"title":"archives","date":"2021-03-13T11:49:15.000Z","url":"/blog/archives/index.html","categories":[[" ",""]]}]