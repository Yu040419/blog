<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>JavaScript 資料型別 | Yu's Blog</title><link rel="stylesheet" type="text/css" href="/blog//css/normalize.css"><link rel="stylesheet" type="text/css" href="/blog//css/highlight.css"><link rel="stylesheet" type="text/css" href="/blog//css/very-simple.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/blog/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><!-- include the sidebar--><!-- include ./includes/sidebar.jade--><!-- Blog title and subtitle--><header><div class="container header"><a id="logo" href="/blog/." class="title">Yu's Blog</a><span class="subtitle">Learning, Writing and Sharing</span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div></header><!-- use checkbox hack for toggle nav-bar on small screens--><input id="menu" type="checkbox"><!-- Navigation Links--><nav id="nav"><div class="container"><a href="/blog/blog/" class="sidebar-nav-item active">Home</a><a href="/blog/archives" class="sidebar-nav-item">Archives</a><a href="/blog/about" class="sidebar-nav-item">About</a></div></nav><div id="header-margin-bar"></div><!-- gallery that comes before the header--><div class="wrapper"><div class="container post-header"><h1>JavaScript 資料型別</h1></div></div><div class="wrapper"><div class="container meta"><div class="post-time">2021-03-09</div><div class="post-tags"><a class="post-tag-none-link" href="/blog/tags/JavaScript/" rel="tag">JavaScript</a></div></div></div><article><div class="container post"><p>JavaScript 資料型別有七種，又分為<strong>原始型別</strong>及<strong>物件型別</strong>。</p>
<p>原始型別有六種：</p>
<ul>
<li>Boolean 布林，例如：true、false</li>
<li>Null 空值</li>
<li>Undefined 未定義</li>
<li>Number 數字，例如：12345</li>
<li>String 字串，例如：<code>&#39;Hello World&#39;</code></li>
<li>Symbol（ES2015 新增） 符號</li>
</ul>
<p>其他的都是物件型別：</p>
<ul>
<li>Object 物件，包含（物件 Object、陣列 Array、函式 Function、時間 Date…）<h3 id="辨別方式"><a href="#辨別方式" class="headerlink" title="辨別方式"></a>辨別方式</h3>可以透過 <code>typeof</code> 來辨別型別<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">1</span>) <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">&#x27;2&#x27;</span>) <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>); <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>()); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> blabla); <span class="comment">// undefined，因為是個 undefined 變數</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是比較特別的案例</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">NaN</span>); <span class="comment">//number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>); <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
註：<code>typeof null</code> 是一個在 JavaScript 剛推出時就存在的 bug，因為擔心改動後會導致太多網站壞掉，所以目前及未來都沒有改的計畫。</li>
</ul>
<p>仔細看會發現，確實像是時間、陣列都會被辨別為物件，雖然畢竟當初分類就是這麼分的，但在實務使用上還是有點不方便，因此其實有其他方式可以更準確地達到實務上的需求 ─ <code>Object.prototype.toString.call(...)</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看後面可以知道確切格式</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>)); <span class="comment">// [Object Null]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call([<span class="number">1</span>, <span class="number">2</span>])); <span class="comment">// [Object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>())); <span class="comment">// [Object Date]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 凡事都有例外</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">NaN</span>)); <span class="comment">// [Object Number]</span></span><br><span class="line"><span class="comment">// 想要驗證 NAN，isNaN() 是唯一解</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="原始型別-VS-物件型別"><a href="#原始型別-VS-物件型別" class="headerlink" title="原始型別 VS 物件型別"></a>原始型別 VS 物件型別</h3><h4 id="可否更改原值"><a href="#可否更改原值" class="headerlink" title="可否更改原值"></a>可否更改原值</h4><p>原始型別只能重新賦值，不能更改原值，比方說</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;aa&#x27;</span>;</span><br><span class="line">str.toUpperCase(); <span class="comment">// 將字串變大寫</span></span><br><span class="line"><span class="built_in">console</span>.log(str);  <span class="comment">// 還是 aa，因為字串是原始型別不能更改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;aa&#x27;</span>;</span><br><span class="line">str = str.toUpperCase(); <span class="comment">// 將自串變大寫的值賦值到變數中</span></span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 重新賦值後就會變 AA</span></span><br></pre></td></tr></table></figure>
<p>物件型別可以更改原值，比方說</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line">arr.push(<span class="string">&#x27;c&#x27;</span>); <span class="comment">// 在陣列中加入 &#x27;c&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]，原本的 arr 會直接更改</span></span><br></pre></td></tr></table></figure>
<h4 id="變數存放方式"><a href="#變數存放方式" class="headerlink" title="變數存放方式"></a>變數存放方式</h4><p>之所以會有這樣的差別，最大的差別就在於變數存放的方式。可以想像成變數名稱都是一張 memo 紙，而變數是一個箱子。</p>
<p>在原始型別當中，寫著變數名稱的 memo 紙貼著的箱子裡，放的就是變數的值，但在物件型別當中，寫著變數名稱的 memo 紙貼著的箱子裡，放的是一個記憶體位置，記憶體位置中放的才是變數的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;aa&#x27;</span>; <span class="comment">// &#x27;aa&#x27; 真的放在 str 貼著的箱子裡</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]; <span class="comment">// arr 貼著的箱子裡放的是記憶體位置 0x01，0x01 裡放的才是 [&#x27;a&#x27;, &#x27;b&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> str1 = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str === str1); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// 變數內存著記憶體位置 0x01</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// 變數內存著記憶體位置 0x02</span></span><br><span class="line"><span class="built_in">console</span>.log(arr === arr1); <span class="comment">// false，因為記憶體位置不同</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> arr1 = arr; <span class="comment">// arr 把記憶體位置分享給 arr1，目前兩個變數都存著一樣的記憶體位置</span></span><br><span class="line"><span class="built_in">console</span>.log(arr === arr1); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因此在更改物件型別值的時候要注意</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> arr1 = arr;</span><br><span class="line">arr1.push(<span class="number">3</span>); <span class="comment">// 因為指向同個記憶體位置，當更改 arr1 時 arr 也會被改到</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始型別</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;aa&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> str1 = str;</span><br><span class="line">str1.toUpperCase();</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// &#x27;aa&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">// &#x27;aa&#x27;，因為前面有說原始型別不能直接更改只能重新賦值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;aa&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> str1 = str;</span><br><span class="line">str1 = str1.toUpperCase(); <span class="comment">// 重新賦值</span></span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// &#x27;aa&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">// &#x27;AA&#x27;，重新賦值後更改了，但不影響其他變數</span></span><br></pre></td></tr></table></figure>
<p>綜合以上，我們會稱 ==物件型別是可變的 mutable，原始型別是不可變的 immutable==。</p>
<h3 id="與-與"><a href="#與-與" class="headerlink" title="= 與 == 與 ==="></a>= 與 == 與 ===</h3><ul>
<li><code>=</code>：賦值</li>
<li><code>==</code>：兩邊進行比較，且會自動進行型別轉換</li>
<li><code>===</code>：兩邊進行比較，但不進行型別轉換<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="string">&#x27;1&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a === <span class="string">&#x27;1&#x27;</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a = <span class="number">2</span>) &#123; <span class="comment">// 這邊會賦值</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;a = 2&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;a = 1&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 印出 &#x27;a = 2&#x27;</span></span><br></pre></td></tr></table></figure>
因此在比較時，永遠都是用 <code>===</code> 最可靠。關於更多的 <code>==</code> 與 <code>===</code> 比較可參考這個 <a target="_blank" rel="noopener" href="https://dorey.github.io/JavaScript-Equality-Table/">好懂表格</a>。</li>
</ul>
<p>另外，<code>NaN</code> 不大於、小於、等於任何數字或是 <code>NaN</code>，<code>NaN</code> 與任何數字運算也都會變成 <code>NaN</code> 。</p>
</div><!-- comment system--><div class="container"><hr></div></article><footer id="footer"><div class="container"><div class="bar"><div class="social"><a href="https://github.com/Yu040419" target="_blank"><i class="fa fa-github"></i></a><a href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></div><div class="footer">© 2021 <a href="/" rel="nofollow">Yu</a>. Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo</a>. Theme <a target="_blank" href="https://github.com/lotabout/very-simple">very-simple</a>.</div></div></div></footer><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>