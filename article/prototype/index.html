<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>什麼是 prototype ? | Yu's Blog</title><link rel="stylesheet" type="text/css" href="/blog//css/normalize.css"><link rel="stylesheet" type="text/css" href="/blog//css/highlight.css"><link rel="stylesheet" type="text/css" href="/blog//css/very-simple.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/blog/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><!-- include the sidebar--><!-- include ./includes/sidebar.jade--><!-- Blog title and subtitle--><header><div class="container header"><a id="logo" href="/blog/." class="title">Yu's Blog</a><span class="subtitle">Learning, Writing and Sharing</span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div></header><!-- use checkbox hack for toggle nav-bar on small screens--><input id="menu" type="checkbox"><!-- Navigation Links--><nav id="nav"><div class="container"><a href="/blog/" class="sidebar-nav-item">Home</a><a href="/blog/archives" class="sidebar-nav-item">Archives</a><a href="/blog/about" class="sidebar-nav-item">About</a></div></nav><div id="header-margin-bar"></div><!-- gallery that comes before the header--><div class="wrapper"><div class="container post-header"><h1>什麼是 prototype ?</h1></div></div><div class="wrapper"><div class="container meta"><div class="post-time">2021-03-09</div><div class="post-tags"><a class="post-tag-none-link" href="/blog/tags/JavaScript/" rel="tag">JavaScript</a></div></div></div><article><div class="container post"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 ES5 的 JS 物件導向中，function 被當成建構子以及 class 用，因此被稱為構造函數。構造函數可透過語法 <code>new</code> 建造一個 instance 實體，也可以透過 <code>prototype</code> 做出共用的 method 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Calculator</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 用 function 來取代 class 名稱跟建構子</span></span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.text = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 透過在剛的 Calculator function 名稱後加上 .prototype 加上.function 名稱</span></span><br><span class="line">Calculator.prototype.input = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.text += str;</span><br><span class="line">&#125;;</span><br><span class="line">Calculator.prototype.getResult = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">eval</span>(<span class="built_in">this</span>.text);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> calculateA = <span class="keyword">new</span> Calculator(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> calculateB = <span class="keyword">new</span> Calculator(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"><span class="comment">// 底下是重點</span></span><br><span class="line"><span class="built_in">console</span>.log(calculateA.input === calculateB.input); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>不過 JS 是如何知道 <code>calculateA.input</code> 等同於 <code>calculateB.input</code> 的呢？或者可以換個問題，JS 是如何繼承 method 跟 property 的呢？</p>
<blockquote>
<p>透過 <code>__proto__</code></p>
</blockquote>
<h3 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a><code>__proto__</code></h3><p>當我們建造 instance 時，JS 會自動幫我們在 instance 加上 <code>__proto__</code> 這個屬性，讓 instance 要使用該 method 找不到時，可以循著 <code>__proto__</code> 連結，往上找到有這個 method 的 <code>prototype</code>，以上面的例子來說，有點類似這個概念：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 實體 A</span></span><br><span class="line">calculateA &#123;</span><br><span class="line">  name: A,</span><br><span class="line">  text: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  __proto__: Calculator.prototype</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 實體 B</span></span><br><span class="line">calculateB &#123;</span><br><span class="line">  name: B,</span><br><span class="line">  text: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  __proto__: Calculator.prototype</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 構造函式的 prototype （放共用的 method &amp; property）</span></span><br><span class="line">Calculator.prototype &#123;</span><br><span class="line">  input: <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.text += str;</span><br><span class="line">  &#125;,</span><br><span class="line">  getResult: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">eval</span>(<span class="built_in">this</span>.text);</span><br><span class="line">  &#125;,</span><br><span class="line">  __proto__: <span class="built_in">Object</span>.prototype <span class="comment">// 構造函式的 prototype 也有 __proto__ 連結到 Object.prototype</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最頂層是物件的 prototype</span></span><br><span class="line"><span class="built_in">Object</span>.prototype &#123;</span><br><span class="line">  __proto__: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像這樣不停往上找，從</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">            透過 calculateA.__proto__ 找到</span><br><span class="line">calculateA --------------------------------&gt; Calculator.prototype</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                      透過 Calculator.prototype.__proto__ 找到</span><br><span class="line">Calculator.prototype ------------------------------------------&gt; Object.prototype</span><br></pre></td></tr></table></figure>
<p>　　</p>
<blockquote>
<p>這個透過 <code>__proto__</code> 尋找的過程，被稱為 <strong>prototype chain 原型鍊</strong> 。</p>
</blockquote>
<h2 id="驗證"><a href="#驗證" class="headerlink" title="驗證"></a>驗證</h2><p>以下介紹三種方式驗證原型鍊：</p>
<p><strong>一、透過 <code>===</code></strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(calculateA.__proto__ === Calculator.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(calculateA.__proto__.input === Calculator.prototype.input); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 連接的 __proto__ 可以被省略</span></span><br><span class="line"><span class="built_in">console</span>.log(calculateA.input === Calculator.prototype.input); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>值得注意的是，不只有建構式的 prototype 才有 <code>__proto__</code>，建構式本身也有 <code>__proto__</code>。</p>
<p>以上面的例子來說，Calculator 這個建構式的 <code>__proto__</code>會連接到 Function.prototype。 Function.prototype 的 <code>__proto__</code> 則連接到頂層的 Object.prototype。</p>
<p>仔細想想其實一切都很合理，Calculator 本來就是 Function，連接到 Function 很正常；而 Function 本來就是 Object，連接到 Object 也很正常。可以想像成以下這樣</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Calculator &#123;</span><br><span class="line">  __proto__ : <span class="built_in">Function</span>.prototype</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype &#123;</span><br><span class="line">  __proto__: <span class="built_in">Object</span>.prototype</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一樣都連到頂層的 Object.prototype</span></span><br><span class="line"><span class="built_in">Object</span>.prototype &#123;</span><br><span class="line">  __proto__: <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Calculator.__proto__ === <span class="built_in">Function</span>.prototype) <span class="comment">// true (1)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">// true (2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因為 (1) 是 true 所以可以把 (2) 改寫成以下</span></span><br><span class="line"><span class="built_in">console</span>.log(Calculator.__proto__.__proto__ === <span class="built_in">Object</span>.prototype)</span><br></pre></td></tr></table></figure>

<p><strong>二、 透過 <code>hasOwnProperty</code></strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(calculateA.hasOwnProperty(<span class="string">&quot;input&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(calculateA.__proto__.hasOwnProperty(<span class="string">&quot;input&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Calculator.prototype.hasOwnProperty(<span class="string">&quot;input&quot;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>三、 透過 <code>instanceOf</code></strong><br>如果 <code>A instanceOf B</code> A 是 B 的實體的話，會回傳 <code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(calculateA <span class="keyword">instanceof</span> Calculator); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(calculateA <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意下面</span></span><br><span class="line"><span class="comment">// constructor 是 Function 的實體</span></span><br><span class="line"><span class="built_in">console</span>.log(Calculator <span class="keyword">instanceof</span> <span class="built_in">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// constructor 也是是 Object 的實體</span></span><br><span class="line"><span class="built_in">console</span>.log(Calculator <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 底下是特別的例子</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><p>其實每個的 prototype 底下，除了共用的 method、property 以及 <code>__proto__</code> 外，還有一個叫做 <code>constructor</code> 的屬性。</p>
<p>在前面我們透過 <code>instanceOf</code> 驗證原形鍊時，得知不只是 <code>new</code> 創建出來的 instance 才是 instance，像是 constructor 也是 Object 的 instance。</p>
<p>所以相反的，<code>Object.prototype</code> 底下的 constructor 屬性也是 Object，因為他們自己就是建構式，可以 new 出 constructor。當然 <code>Calculator.prototype.constructor = Calculator</code> ，因為 Calculator 本身就是 constructor 拉，他的 constructor 也自然指向自己。</p>
<p>因此任何 <code>X.prototype.constructor = X</code> 。</p>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>了解原型鍊後就容易理解 <code>new</code> 是如何運作的，其實他幫我們做的步驟如下：</p>
<ol>
<li>創建一個空物件（以下簡稱 O），將 O 當成是 <code>new</code> 出來的實體</li>
<li>透過 <code>__proto__</code> 讓 O 跟建構函式產生連結</li>
<li>將 O 當成建構函式裡的 <code>this</code> 並透過 <code>call</code> 或 <code>apply</code> 執行建構函式</li>
<li>回傳 O</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constructor 建構函式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Calculator</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.num = num;</span><br><span class="line">  <span class="built_in">this</span>.result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建構函式的 prototype</span></span><br><span class="line">Calculator.prototype.calculate = <span class="function"><span class="keyword">function</span> (<span class="params">operator, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">this</span>.result = <span class="built_in">eval</span>(<span class="built_in">this</span>.num + operator + num2));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自己試著用函式做出類似 new 的功能 -&gt; let calA = new Calculator(5)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newCal</span>(<span class="params">constructor, <span class="built_in">arguments</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> O = &#123;&#125;; <span class="comment">// 創建類似實體的空物件</span></span><br><span class="line">  O.__proto__ = <span class="title">constructor</span>.<span class="title">prototype</span>; <span class="comment">// 透過 __proto__ 連接實體跟建構函式</span></span><br><span class="line">  <span class="title">constructor</span>.<span class="title">apply</span>(<span class="params">O, <span class="built_in">arguments</span></span>); <span class="comment">// 執行建構函式</span></span><br><span class="line">  <span class="keyword">return</span> O; <span class="comment">// 回傳類似實體的空物件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> calA = newCal(Calculator, [<span class="number">5</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(calA.calculate(<span class="string">&quot;*&quot;</span>, <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 上面跟底下透過 new 的實作出來結果相同</span></span><br><span class="line"><span class="comment">// let calA = new Calculator(5);</span></span><br><span class="line"><span class="comment">// console.log(calA.calculate(&#x27;*&#x27;, 2));</span></span><br></pre></td></tr></table></figure>
</div><!-- comment system--><div class="container"><hr></div></article><footer id="footer"><div class="container"><div class="bar"><div class="social"><a href="https://github.com/https://github.com/Yu040419" target="_blank"><i class="fa fa-github"></i></a><a href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></div><div class="footer">© 2021 <a href="/" rel="nofollow">Yu</a>. Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo</a>. Theme <a target="_blank" href="https://github.com/lotabout/very-simple">very-simple</a>.</div></div></div></footer><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>